#include <windows.h>
#include "RingBuffer.h"

namespace covEngine
{
	//////////////////////////////////////////////////////////////////
	// 생성자
	//////////////////////////////////////////////////////////////////
	RingBuffer::RingBuffer()
	{
		m_iBufferSize = eBUFFER_SIZE;
		m_iWritePos = 0;
		m_iReadPos = 0;
		memset(m_bypBuffer, 0, eBUFFER_SIZE);
	}


	//////////////////////////////////////////////////////////////////
	// 소멸자
	//////////////////////////////////////////////////////////////////
	RingBuffer::~RingBuffer()
	{

	}


	//////////////////////////////////////////////////////////////////
	// 버퍼 사이즈 얻기
	//////////////////////////////////////////////////////////////////
	const int RingBuffer::GetBufferSize(void) const
	{
		return m_iBufferSize;
	}


	//////////////////////////////////////////////////////////////////
	// 읽기 위치 얻기
	//////////////////////////////////////////////////////////////////
	char* RingBuffer::GetReadPos(void) const
	{
		return (char*)(m_bypBuffer + m_iReadPos);
	}


	//////////////////////////////////////////////////////////////////
	// 쓰기 위치 얻기
	//////////////////////////////////////////////////////////////////
	char* RingBuffer::GetWritePos(void) const
	{
		return (char*)(m_bypBuffer + m_iWritePos);
	}


	//////////////////////////////////////////////////////////////////
	// 버퍼 시작 포인터 얻기
	//////////////////////////////////////////////////////////////////
	char* RingBuffer::GetBufferPtr(void) const
	{
		return (char*)m_bypBuffer;
	}


	//////////////////////////////////////////////////////////////////
	// 버퍼가 비어있는지 확인
	//////////////////////////////////////////////////////////////////
	const bool RingBuffer::IsEmpty(void) const
	{
		if (m_iReadPos == m_iWritePos)
		{
			return true;
		}

		return false;
	}


	//////////////////////////////////////////////////////////////////
	// 버퍼가 꽉 차있는지 확인
	//////////////////////////////////////////////////////////////////
	const bool RingBuffer::IsFull(void)
	{
		if (0 == GetFreeSize())
		{
			return true;
		}
		return false;
	}


	//////////////////////////////////////////////////////////////////
	// 사용중인 사이즈 얻기
	//////////////////////////////////////////////////////////////////
	const int RingBuffer::GetUseSize(void)
	{
		int iWritePos = m_iWritePos;
		int iReadPos = m_iReadPos;

		if (iWritePos < iReadPos)
		{
			//-------------------------------------
			//#######W            R################
			//-------------------------------------
			return (eBUFFER_SIZE - (iReadPos - iWritePos));
		}
		else
		{
			//-------------------------------------
			//	    R#############W  
			//-------------------------------------
			return iWritePos - iReadPos;
		}
	}


	//////////////////////////////////////////////////////////////////
	// 사용가능 사이즈 얻기
	//////////////////////////////////////////////////////////////////
	const int RingBuffer::GetFreeSize(void)
	{
		int iWritePos = m_iWritePos;
		int iReadPos = m_iReadPos;

		if (iWritePos < iReadPos)
		{
			//-------------------------------------
			//        W###########%R
			//-------------------------------------
			return (iReadPos - iWritePos) - eBUFFER_BLANK;
		}
		else
		{
			//-------------------------------------
			//###%R             W##################
			//-------------------------------------
			return (eBUFFER_SIZE - (iWritePos - iReadPos)) - eBUFFER_BLANK;
		}
	}


	//////////////////////////////////////////////////////////////////
	// 끊기지않고 넣을 수 있는 사이즈 얻기
	//////////////////////////////////////////////////////////////////
	const int RingBuffer::GetNonBrokenPutSize(void)
	{
		int iWritePos = m_iWritePos;
		int iReadPos = m_iReadPos;

		if (iWritePos < iReadPos)
		{
			//-------------------------------------
			//      W############%R               
			//-------------------------------------
			return (iReadPos - iWritePos) - eBUFFER_BLANK;
		}
		else
		{
			//---------------------------------------------------
			//ReadPos가 시작점에 있다면, 맨 마지막 버퍼를 비워야한다.
			//---------------------------------------------------
			if (iReadPos == 0)
			{
				//-------------------------------------
				//R          W########################%
				//-------------------------------------
				return (eBUFFER_SIZE - iWritePos) - eBUFFER_BLANK;
			}
			//---------------------------------------------------
			//ReadPos가 시작점이 아니라면, 남은 버퍼 공간이 전부 사용 가능 공간.
			//---------------------------------------------------
			else
			{
				//-------------------------------------
				//        R       W####################
				//-------------------------------------
				return (eBUFFER_SIZE - iWritePos);
			}
		}
	}


	//////////////////////////////////////////////////////////////////
	// 끊기지않고 읽을 수 있는 사이즈 얻기
	//////////////////////////////////////////////////////////////////
	const int RingBuffer::GetNonBrokenGetSize(void)
	{
		int	iWritePos = m_iWritePos;
		int	iReadPos = m_iReadPos;

		if (iWritePos < iReadPos)
		{
			//-------------------------------------
			//    W      R#########################
			//-------------------------------------
			return eBUFFER_SIZE - iReadPos;
		}
		else
		{
			//-------------------------------------
			//     R#############W
			//-------------------------------------
			return iWritePos - iReadPos;
		}
	}


	//////////////////////////////////////////////////////////////////
	// 큐에 데이터 넣기
	//////////////////////////////////////////////////////////////////
	int RingBuffer::Put(const char* bypSource, int iSize)
	{
		////////////////////////////////////////////////////////////////
		// Case 1 :
		// ReadPos 이동 가능
		// FreeSize보다 NotBrokenSize가 더 크게 나올 수 있다.
		//
		//---------------------------------
		//       W##########%R            |		1. FreeSize
		//---------------------------------
		//       W#################%R     |		2. NotBrokenSize 
		//---------------------------------
		////////////////////////////////////////////////////////////////

		////////////////////////////////////////////////////////////////
		// Case 2 : 
		// ReadPos 이동 가능
		// FreeSize보다 NotBrokenSize가 더 크게 나올 수 없다.
		// 
		//---------------------------------
		//####%R            W#############|	    1. FreeSize
		//---------------------------------
		//############%R    W#############|		2. NotBrokenSize 
		//---------------------------------
		////////////////////////////////////////////////////////////////

		int iFreeSize = GetFreeSize();
		if (iFreeSize == 0 || iSize == 0)
		{
			return 0;
		}

		int iTotalCopySize;

		//--------------------------------------------------------------
		// 쓸 수 있는 사이즈가 요청 사이즈보다 큰 경우, 요청 사이즈 승낙
		//--------------------------------------------------------------
		if (iFreeSize > iSize)
		{
			iTotalCopySize = iSize;
		}
		//--------------------------------------------------------------
		// 쓸 수 있는 사이즈가 요청 사이즈보다 작은 경우, 읽을 수 있는 사이즈만 읽는다.
		//--------------------------------------------------------------
		else
		{
			iTotalCopySize = iFreeSize;
		}

		int iNonBrokenSize = GetNonBrokenPutSize();

		//--------------------------------------------------------------
		// NonBrokenSize가 복사해야할 사이즈보다 클 경우, 
		// 한 번의 복사로 데이터 삽입을 끝낼 수 있다.
		//--------------------------------------------------------------
		if (iTotalCopySize <= iNonBrokenSize)
		{
			memcpy(m_bypBuffer + m_iWritePos, bypSource, iTotalCopySize);
		}
		//--------------------------------------------------------------
		// NonBrokenSize가 복사해야할 사이즈보다 작을 경우, 
		// 두 번의 복사를 통해 데이터 삽입을 끝내야한다.
		//--------------------------------------------------------------
		else
		{
			memcpy(m_bypBuffer + m_iWritePos, bypSource, iNonBrokenSize);
			memcpy(m_bypBuffer, bypSource + iNonBrokenSize, iTotalCopySize - iNonBrokenSize);
		}

		MoveWritePos(iTotalCopySize);

		return iTotalCopySize;
	}


	//////////////////////////////////////////////////////////////////
	// 큐에서 데이터 뽑기
	//////////////////////////////////////////////////////////////////
	int RingBuffer::Get(char* bypDest, int iSize)
	{
		////////////////////////////////////////////////////////////////
		// Case 1 :
		// WritePos 이동 가능
		// UseSize보다 NotBrokenSize가 더 크게 나올 수 있다.
		//
		//---------------------------------
		//       R##########W             |		1. UseSize
		//---------------------------------
		//       R#################W      |		2. NotBrokenSize 
		//---------------------------------
		////////////////////////////////////////////////////////////////

		////////////////////////////////////////////////////////////////
		// Case 2 : 
		// WritePos 이동 가능
		// UseSize보다 NotBrokenSize가 더 크게 나올 수 없다.
		// 
		//---------------------------------
		//#####W            R#############|	    1. UseSize
		//---------------------------------
		//############W     R#############|		2. NotBrokenSize 
		//---------------------------------
		////////////////////////////////////////////////////////////////

		int iUseSize = GetUseSize();
		if (iUseSize == 0 || iSize == 0)
		{
			return 0;
		}

		int iCopySize;
		//--------------------------------------------------------------
		// 읽을 수 있는 사이즈가 요청 사이즈보다 큰 경우, 요청 사이즈 승낙
		//--------------------------------------------------------------
		if (iUseSize > iSize)
		{
			iCopySize = iSize;
		}
		//--------------------------------------------------------------
		// 읽을 수 있는 사이즈가 요청 사이즈보다 작은 경우, 읽을 수 있는 사이즈만 읽는다.
		//--------------------------------------------------------------
		else
		{
			iCopySize = iUseSize;
		}

		int iNonBrokenSize = GetNonBrokenGetSize();

		//--------------------------------------------------------------
		// NonBrokenSize가 복사해야할 사이즈보다 클 경우, 
		// 한 번의 복사로 데이터 출력을 끝낼 수 있다.
		//--------------------------------------------------------------
		if (iCopySize <= iNonBrokenSize)
		{
			memcpy(bypDest, m_bypBuffer + m_iReadPos, iCopySize);
		}
		//--------------------------------------------------------------
		// NonBrokenSize가 복사해야할 사이즈보다 작을 경우, 
		// 두 번의 복사를 통해 데이터 출력을 끝내야한다.
		//--------------------------------------------------------------
		else
		{
			//-------------------------------------------
			//                             ##############
			//-------------------------------------------
			memcpy(bypDest, m_bypBuffer + m_iReadPos, iNonBrokenSize);

			//-------------------------------------------
			// #####                             
			//-------------------------------------------
			memcpy(bypDest + iNonBrokenSize, m_bypBuffer, iCopySize - iNonBrokenSize);
		}

		MoveReadPos(iCopySize);

		return iCopySize;
	}

	//////////////////////////////////////////////////////////////////
	// 큐에서 데이터 뽑기 (읽기 포인터 이동 X)
	//////////////////////////////////////////////////////////////////
	int RingBuffer::Peek(char* bypDest, int iSize)
	{
		////////////////////////////////////////////////////////////////
		// Case 1 :
		// WritePos 이동 가능
		// UseSize보다 NotBrokenSize가 더 크게 나올 수 있다.
		//
		//---------------------------------
		//       R##########W             |		1. UseSize
		//---------------------------------
		//       R#################W      |		2. NotBrokenSize 
		//---------------------------------
		////////////////////////////////////////////////////////////////

		////////////////////////////////////////////////////////////////
		// Case 2 : 
		// WritePos 이동 가능
		// UseSize보다 NotBrokenSize가 더 크게 나올 수 없다.
		// 
		//---------------------------------
		//#####W            R#############|	    1. UseSize
		//---------------------------------
		//############W     R#############|		2. NotBrokenSize 
		//---------------------------------
		////////////////////////////////////////////////////////////////

		int iUseSize = GetUseSize();
		if (iUseSize == 0 || iSize == 0)
		{
			return 0;
		}

		int iCopySize;
		//--------------------------------------------------------------
		// 읽을 수 있는 사이즈가 요청 사이즈보다 큰 경우, 요청 사이즈 승낙
		//--------------------------------------------------------------
		if (iUseSize > iSize)
		{
			iCopySize = iSize;
		}
		//--------------------------------------------------------------
		// 읽을 수 있는 사이즈가 요청 사이즈보다 작은 경우, 읽을 수 있는 사이즈만 읽는다.
		//--------------------------------------------------------------
		else
		{
			iCopySize = iUseSize;
		}

		int iNonBrokenSize = GetNonBrokenGetSize();

		//--------------------------------------------------------------
		// NonBrokenSize가 복사해야할 사이즈보다 클 경우, 
		// 한 번의 복사로 데이터 출력을 끝낼 수 있다.
		//--------------------------------------------------------------
		if (iCopySize <= iNonBrokenSize)
		{
			memcpy(bypDest, m_bypBuffer + m_iReadPos, iCopySize);
		}
		//--------------------------------------------------------------
		// NonBrokenSize가 복사해야할 사이즈보다 작을 경우, 
		// 두 번의 복사를 통해 데이터 출력을 끝내야한다.
		//--------------------------------------------------------------
		else
		{
			//-------------------------------------------
			//                             ##############
			//-------------------------------------------
			memcpy(bypDest, m_bypBuffer + m_iReadPos, iNonBrokenSize);

			//-------------------------------------------
			// #####                             
			//-------------------------------------------
			memcpy(bypDest + iNonBrokenSize, m_bypBuffer, iCopySize - iNonBrokenSize);
		}

		return iCopySize;
	}


	//////////////////////////////////////////////////////////////////
	// 쓰기 포인터 이동
	//////////////////////////////////////////////////////////////////
	int RingBuffer::MoveWritePos(const int iSize)
	{
		//--------------------------------------------------------------
		// 이동한 값이 BufferSize를 초과할 경우 나머지 연산의 나머지가 위치가 된다.
		//--------------------------------------------------------------
		m_iWritePos = (m_iWritePos + iSize) % eBUFFER_SIZE;

		return iSize;
	}


	//////////////////////////////////////////////////////////////////
	// 읽기 포인터 이동
	//////////////////////////////////////////////////////////////////
	int RingBuffer::MoveReadPos(const int iSize)
	{
		//--------------------------------------------------------------
		// 이동한 값이 BufferSize를 초과할 경우 나머지 연산의 나머지가 위치가 된다.
		//--------------------------------------------------------------
		m_iReadPos = (m_iReadPos + iSize) % eBUFFER_SIZE;

		return iSize;
	}


	//////////////////////////////////////////////////////////////////
	// 버퍼 초기화
	//////////////////////////////////////////////////////////////////
	void RingBuffer::Clear(void)
	{
		m_iWritePos = 0;
		m_iReadPos = 0;
	}
}